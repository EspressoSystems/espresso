////////////////////////////////////////////////////////////////////////////////
// Hierarchical deterministic key generation
//
// This module provides an interface for procedurally generating a tree of keys.
// It does not implement the full BIP 32 standard for HD wallets, only the
// features relevant to our system. For example, BIP 32 provides features for
// deriving public keys from parent public keys without knowing any private keys,
// to allow for trustless key rotation. This (key rotation) is less important in
// our system, which provides unlinkability by default.
//
// The keys generated by this interface are 32-byte pseudo-random values with no
// internal structure. They have no relationship to elliptic curve points, but
// they can be used as a random seed for generating elliptic curve keys for use
// in the wallet. The lack of structure makes these keys useful for other
// applications too, though, such as encryption and decryption.
//
// The relationship between derived keys and their parents can be described as a
// tree. A single root KeyTree is generated from some external means (such as
// entropy, or from a password using a KDF). This root tree can be used to derive
// sub-trees using `derive_sub_tree`, and any KeyTree can be used to derive more
// sub-trees as well as leaf keys. Each derived KeyTree and Key is a commitment
// to its parent, but the parent key cannot be efficiently computed from the
// child.
//
// KeyTrees are opaque. They cannot be used for anything other than to derive
// more keys. Only leaf Keys can be used as keys in applications, via the
// `as_bytes` method. Each key commits to its role: leaf Keys and KeyTrees will
// not collide, even if they are derived from the same parent key with the same
// `id`.

use super::secret::Secret;
use jf_aap::keys::{AuditorKeyPair, FreezerKeyPair, UserKeyPair};
use mnemonic::decode;
use rand_chacha::rand_core::SeedableRng;
use rand_chacha::rand_core::{CryptoRng, RngCore};
use rand_chacha::ChaChaRng;
use sha3::{Digest, Sha3_256, Sha3_512};
use std::convert::TryInto;
use zeroize::Zeroize;

// Salt used when deriving keys from passwords.
pub type Salt = [u8; 32];

#[derive(Clone, Debug)]
pub struct KeyTree {
    // Sub-trees are 64 bytes, twice as large as the actual keys, to make it much harder to break
    // security upwards through the tree. This is probably not strictly necessary (32 bytes is
    // already quite large) but it is an extra layer of security for sub-tree separation, which is
    // the most important security property of this system.
    //
    // BIP32 uses a similar idea by extending their keys with an extra 32 bytes of entropy (the
    // chain code).
    state: Secret<[u8; 64]>,
    // We track the depth in the tree of each sub-tree, so that we can mix it into the hash function
    // at each level as a deterministic salt. This effectively changes the hash function used at
    // each level of the tree, making us less vulnerable to precomputation attacks even in the
    // presence of sub-tree ID reuse.
    depth: usize,
}

macro_rules! derive_keypair {
    ($self: expr, $label:expr, $id: expr, $tar:ident) => {{
        let id = [$label.as_bytes(), $id].concat();
        let derived_seed = $self.derive_key_internal(&id);
        let mut rng = ChaChaRng::from_seed(*derived_seed.as_bytes().open_secret());
        $tar::generate(&mut rng)
    }};
}

impl KeyTree {
    /// Build a new KeyTree from prng; also returns a 24-word mnemonic
    /// that can be used to recover this KeyTree
    pub fn random(rng: &mut (impl CryptoRng + RngCore)) -> Result<(Self, String), argon2::Error> {
        let mut seed = [0u8; 32];
        rng.fill_bytes(&mut seed);
        let mnemonic = mnemonic::to_string(seed.as_ref());
        let key_tree = Self::from_mnemonic(mnemonic.as_bytes())?;
        Ok((key_tree, mnemonic))
    }

    pub fn from_password(
        rng: &mut (impl CryptoRng + RngCore),
        password: &[u8],
    ) -> Result<(Self, Salt), argon2::Error> {
        let mut salt = Salt::default();
        rng.fill_bytes(&mut salt);
        let key = Self::from_password_and_salt(password, &salt)?;
        Ok((key, salt))
    }

    pub fn from_password_and_salt(password: &[u8], salt: &[u8]) -> Result<Self, argon2::Error> {
        let mut key = Secret::<[u8; 64]>::build();
        let config = argon2::Config {
            hash_length: key.len() as u32,
            ..Default::default()
        };
        let mut hash = argon2::hash_raw(password, salt, &config)?;
        *key = hash.clone().try_into().unwrap();
        hash.zeroize();
        Ok(Self {
            state: key.finalize(),
            depth: 0,
        })
    }

    /// Input a mnemonic phrase, in the form of bytes,
    /// i.e., "digital-apollo-aroma--rival-artist-rebel"
    /// initializing a key tree.
    ///
    /// We require that the input mnemonic phrase is 24 words
    /// (equivalently, 32 bytes of seed), return a decoding error
    /// if the mnemonic is not decoded successfully; or if the
    /// input length is incorrect.
    pub fn from_mnemonic(mnemonic: &[u8]) -> Result<Self, argon2::Error> {
        let mut decoded_seed = Vec::<u8>::new();
        decode(mnemonic, &mut decoded_seed).map_err(|_| argon2::Error::DecodingFail)?;
        if decoded_seed.len() != 32 {
            return Err(argon2::Error::DecodingFail);
        }
        // 32 bytes of salt
        let salt = "This is a salt to seed a KeyTree";
        Self::from_password_and_salt(decoded_seed.as_ref(), salt.as_bytes())
    }

    pub fn derive_sub_tree(&self, id: &[u8]) -> KeyTree {
        // Note that the hash for deriving a new sub-tree does not need to include a commitment to
        // the role of the key (sub-tree vs key) because sub-trees and keys are different sizes and
        // thus cannot suffer from domain confusion.
        let mut digest = Sha3_512::new()
            // Commit to the parent key.
            .chain(self.state.open_secret())
            // Mix in the depth of the tree as a salt.
            .chain(&self.depth.to_le_bytes())
            .chain(id)
            .finalize();
        // The try_into will always succeed, because the hash output size is a slice of 64 bytes.
        // There just isn't an `as_mut() -> &[u8; 64]` method for GenericArrays as large as 64.
        Self {
            state: Secret::new(digest.as_mut().try_into().unwrap()),
            depth: self.depth + 1,
        }
    }

    // The internal API that derive a Key
    fn derive_key_internal(&self, id: &[u8]) -> Key {
        // Note that the hash for deriving a new key does not need to include a commitment to the
        // role of the key (key vs sub-tree) because keys and sub-trees are different sizes and thus
        // cannot suffer from domain confusion.
        let mut digest = Sha3_256::new()
            // Commit to the parent key.
            .chain(self.state.open_secret())
            // Mix in the depth of the tree as a salt.
            .chain(&self.depth.to_le_bytes())
            .chain(id)
            .finalize();
        Key(Secret::new(digest.as_mut()))
    }

    /// derive a generic key from the KeyTree with certain id
    pub fn derive_key(&self, id: &[u8]) -> Key {
        let id = ["default key".as_ref(), id].concat();
        self.derive_key_internal(id.as_ref())
    }

    /// derive a user key pair from the KeyTree with certain id
    pub fn derive_user_keypair(&self, id: &[u8]) -> UserKeyPair {
        derive_keypair!(self, "user keypair", id, UserKeyPair)
    }

    /// derive an auditor key pair from the KeyTree with certain id
    pub fn derive_auditor_keypair(&self, id: &[u8]) -> AuditorKeyPair {
        derive_keypair!(self, "auditor keypair", id, AuditorKeyPair)
    }

    /// derive a freezer key pair from the KeyTree with certain id
    pub fn derive_freezer_keypair(&self, id: &[u8]) -> FreezerKeyPair {
        derive_keypair!(self, "freezer keypair", id, FreezerKeyPair)
    }
}

#[derive(Clone, Debug)]
pub struct Key(Secret<[u8; 32]>);

impl Key {
    pub fn as_bytes(&self) -> &Secret<[u8; 32]> {
        &self.0
    }
}

#[test]
fn test_key_tree_gen() {
    use ark_std::rand::thread_rng;

    let mut rng = thread_rng();
    let (key_tree, mnemonic) = KeyTree::random(&mut rng).unwrap();
    let key_tree_recovered = KeyTree::from_mnemonic(mnemonic.as_bytes()).unwrap();

    assert_eq!(
        key_tree.state.open_secret(),
        key_tree_recovered.state.open_secret()
    )
}
